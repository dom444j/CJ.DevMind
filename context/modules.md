## CJ.DevMind: MÃ³dulos y Agentes (Actualizado)

### VisiÃ³n General

**CJ.DevMind** estÃ¡ compuesto por **30 agentes especializados** (anteriormente 23, con la adiciÃ³n de 5 nuevos agentes: `StyleAgent`, `TestAgent`, `SelfImprovementAgent`, `CodeReviewAgent`, y una actualizaciÃ³n significativa al `ComponentAgent`) que colaboran para asistir en todas las fases del desarrollo de software: desde la definiciÃ³n de requisitos hasta la implementaciÃ³n, calidad, infraestructura, documentaciÃ³n, y lanzamiento. AdemÃ¡s, incluye `BaseAgent` como nÃºcleo y `VSCodeAgentBridge` como un componente de integraciÃ³n (no un agente especializado), lo que lleva el total de elementos en la jerarquÃ­a a **32**. Los agentes estÃ¡n organizados en una estructura jerÃ¡rquica, con un **BaseAgent** como nÃºcleo, y se dividen en categorÃ­as funcionales: **Meta-Nivel**, **Frontend**, **Backend**, **Calidad**, **Infraestructura**, **DocumentaciÃ³n**, **Negocio**, y **Otros**. Cada agente tiene responsabilidades especÃ­ficas, interactÃºa con otros segÃºn un grafo de dependencias dinÃ¡mico, y opera bajo un ciclo de vida de tareas definido (PENDING, IN_PROGRESS, BLOCKED, REVIEW, COMPLETED, ERROR, CANCELLED). El sistema estÃ¡ diseÃ±ado para integrarse como una extensiÃ³n de VS Code, con una arquitectura hÃ­brida que combina un cliente ligero en VS Code y un servidor backend para tareas pesadas.

#### CaracterÃ­sticas Clave
- **Persistencia de Contexto**: El estado del sistema (tareas, dependencias, mÃ©tricas, cÃ³digo, documentaciÃ³n, decisiones, tendencias del mercado, preferencias del usuario) se guarda automÃ¡ticamente con checkpoints periÃ³dicos (cada 100 operaciones o 10 minutos) en `cjdevmind.db` y en el almacenamiento local de VS Code (`vscode.Memento`, `vscode.workspace.fs`).
- **EjecuciÃ³n AutÃ³noma Supervisada**: Modo simulaciÃ³n para previsualizar acciones, rollbacks automÃ¡ticos con puntos de restauraciÃ³n, logs transaccionales para operaciones crÃ­ticas, y niveles de aprobaciÃ³n humana para tareas en estado REVIEW.
- **GestiÃ³n de Dependencias**: Grafo dinÃ¡mico gestionado por el **OrchestratorAgent**, con resoluciÃ³n de bloqueos y priorizaciÃ³n inteligente basada en una **PriorityQueue**.
- **Ciclo de Vida de Tareas**: Estados gestionados por el **TaskManager** (PENDING, IN_PROGRESS, BLOCKED, REVIEW, COMPLETED, ERROR, CANCELLED), con transiciones dinÃ¡micas y notificaciones en VS Code.
- **Dashboard de SupervisiÃ³n**: VisualizaciÃ³n en tiempo real de tareas, agentes, mÃ©tricas de ROI, sistema de crÃ©ditos, y gestiÃ³n de licencias, renderizado en un webview de VS Code.
- **Modelo de Negocio Integrado**: Licencias (Community, Professional, Enterprise), sistema de crÃ©ditos para desbloquear funcionalidades y comprar extensiones, y un marketplace de extensiones integrado en VS Code.
- **Soporte para Proyectos de Cualquier Escala**: Desde proyectos pequeÃ±os (por ejemplo, una tienda en lÃ­nea sencilla) hasta proyectos complejos (por ejemplo, una app MLM hÃ­brida con tienda internacional y realidad aumentada).
- **IntegraciÃ³n con VS Code**: Los agentes se ejecutan como parte de una extensiÃ³n de VS Code, con comandos personalizados (`cjdevmind.[agent]`), webviews para el dashboard y el marketplace, y soporte para modo offline.
- **Modo Offline**: Operaciones sin conexiÃ³n usando modelos locales (Llama, Mistral), almacenamiento local, y sincronizaciÃ³n al reconectar.
- **Seguridad**: GestiÃ³n de credenciales, validaciÃ³n de entrada, auditorÃ­a, niveles de aprobaciÃ³n, rollbacks automÃ¡ticos, y logs transaccionales, con integraciÃ³n segura en VS Code (`vscode.SecretStorage`).
- **AutoextensiÃ³n y Automejora**:
  - **AutoextensiÃ³n SegÃºn Requerimientos**: El **ExtensionAgent** permite extender las capacidades del sistema instalando extensiones del marketplace (por ejemplo, plugins de AR o multilenguaje), lo que funcionalmente puede equivaler a aÃ±adir nuevas capacidades como si fueran "nuevos agentes", aunque no crea agentes nuevos en la jerarquÃ­a.
  - **Automejora de Agentes**: El **SelfImprovementAgent** optimiza el comportamiento de los agentes existentes analizando su historial de ejecuciÃ³n y ajustando prompts, lÃ³gica, o configuraciones para mejorar su rendimiento y adaptarse a los requerimientos del proyecto.

---

## ðŸ”„ JerarquÃ­a de Agentes (Actualizada)

La jerarquÃ­a incluye **32 elementos**: 30 agentes especializados, `BaseAgent` (nÃºcleo), y `VSCodeAgentBridge` (componente de integraciÃ³n, no un agente especializado). Los nuevos agentes (`StyleAgent`, `TestAgent`, `SelfImprovementAgent`, `CodeReviewAgent`) y la actualizaciÃ³n de `ComponentAgent` se integran en las categorÃ­as correspondientes:

```
BaseAgent
â”œâ”€â”€ Meta-Nivel
â”‚   â”œâ”€â”€ QuestionAgent
â”‚   â”œâ”€â”€ VisionAgent
â”‚   â”œâ”€â”€ ArchitectAgent
â”‚   â”œâ”€â”€ OrchestratorAgent
â”‚   â””â”€â”€ ExtensionAgent
â”œâ”€â”€ Frontend
â”‚   â”œâ”€â”€ UIDesignAgent
â”‚   â”œâ”€â”€ LayoutAgent
â”‚   â”œâ”€â”€ ComponentAgent (Actualizado)
â”‚   â”œâ”€â”€ FrontendSyncAgent
â”‚   â””â”€â”€ StyleAgent (Nuevo)
â”œâ”€â”€ Backend
â”‚   â”œâ”€â”€ APIAgent
â”‚   â”œâ”€â”€ LogicAgent
â”‚   â”œâ”€â”€ DatabaseAgent
â”‚   â””â”€â”€ IntegrationAgent
â”œâ”€â”€ Calidad
â”‚   â”œâ”€â”€ TestingAgent
â”‚   â”œâ”€â”€ SecurityAgent
â”‚   â”œâ”€â”€ PerformanceAgent
â”‚   â”œâ”€â”€ RefactorAgent
â”‚   â”œâ”€â”€ TestAgent (Nuevo)
â”‚   â”œâ”€â”€ SelfImprovementAgent (Nuevo)
â”‚   â””â”€â”€ CodeReviewAgent (Nuevo)
â”œâ”€â”€ Infraestructura
â”‚   â”œâ”€â”€ DevOpsAgent
â”‚   â”œâ”€â”€ MonitorAgent
â”‚   â”œâ”€â”€ DashboardAgent
â”‚   â””â”€â”€ AnalyticsAgent
â”œâ”€â”€ DocumentaciÃ³n
â”‚   â”œâ”€â”€ DocAgent
â”‚   â””â”€â”€ MemoryAgent
â”œâ”€â”€ Negocio
â”‚   â”œâ”€â”€ BusinessAgent
â”‚   â”œâ”€â”€ MarketAgent
â”‚   â””â”€â”€ LaunchAgent
â””â”€â”€ Otros
    â””â”€â”€ VSCodeAgentBridge
```

---

### Detalle de Agentes por CategorÃ­a (Actualizado)

#### BaseAgent
- **Responsabilidad**: NÃºcleo del sistema, proporciona funcionalidades bÃ¡sicas compartidas por todos los agentes especializados, con soporte para integraciÃ³n con VS Code.
- **Capacidades**:
  - ComunicaciÃ³n entre agentes mediante un **EventBus** con canales temÃ¡ticos (`frontend`, `backend`, `calidad`, `infraestructura`, `documentacion`, `negocio`).
  - Acceso al sistema de memoria persistente (gestionado por el **MemoryAgent**), incluyendo almacenamiento local en VS Code.
  - GestiÃ³n de prompts y respuestas de LLMs (OpenAI, Anthropic, modelos locales como Llama y Mistral).
  - Registro de comandos en VS Code mediante el **VSCodeAdapter**.
  - Almacenamiento seguro de credenciales usando `vscode.SecretStorage`.
- **Interacciones**:
  - Sirve como base para todos los agentes especializados, proporcionando mÃ©todos comunes como `execute`, `callLLM`, `publishEvent`, y `storeLocalData`.
  - Usa el **VSCodeAdapter** para interactuar con el entorno de VS Code (comandos, webviews, almacenamiento).
- **ImplementaciÃ³n**:
  ```typescript
  abstract class BaseAgent {
    protected context: Context;
    protected llmProvider: LLMProvider;
    protected logger: Logger;
    protected memory: MemoryService;
    protected eventBus: EventBus;
    protected vscodeAdapter: VSCodeAdapter;

    constructor(config: AgentConfig) {
      this.context = new Context(config.contextPath);
      this.llmProvider = LLMFactory.create(config.llmProvider);
      this.logger = new Logger(config.name);
      this.memory = MemoryService.getInstance();
      this.eventBus = EventBus.getInstance();
      this.vscodeAdapter = new VSCodeAdapter(config.vscodeContext);
    }

    abstract async execute(input: string): Promise<AgentResult>;

    protected async callLLM(prompt: string, options?: LLMOptions): Promise<string> {
      return this.llmProvider.call(prompt, options);
    }

    protected publishEvent(event: AgentEvent): void {
      this.eventBus.publish(event.type, event.data);
    }

    protected async queryMemory(query: string): Promise<MemoryResult> {
      return this.memory.query(query);
    }

    protected async saveToMemory(data: any, metadata: any): Promise<void> {
      return this.memory.store(data, metadata);
    }

    protected async registerVSCodeCommand(command: string, callback: (...args: any[]) => any): void {
      this.vscodeAdapter.registerCommand(command, callback);
    }

    protected async storeLocalData(key: string, value: any): Promise<void> {
      this.vscodeAdapter.storeLocalData(key, value);
    }
  }
  ```

#### 1. Meta-Nivel (CoordinaciÃ³n y Contexto)

- **QuestionAgent**
  - **Responsabilidad**: Interpreta y descompone requerimientos del usuario en tareas accionables, con interacciÃ³n directa en VS Code.
  - **Capacidades**:
    - Analiza entradas en lenguaje natural (por ejemplo, "Crear una app MLM con autenticaciÃ³n").
    - Genera un conjunto de tareas para el **OrchestratorAgent** mediante un cuestionario interactivo.
    - Usa notificaciones de VS Code (`vscode.window.showInputBox`) para recopilar informaciÃ³n adicional.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ COMPLETED.
  - **Interacciones**:
    - Pasa tareas al **OrchestratorAgent**.
    - Usa el **MemoryAgent** para almacenar contexto histÃ³rico (por ejemplo, preferencias del usuario).
    - Notifica al usuario mediante VS Code (`vscode.window.showInformationMessage`).
  - **Ejemplo**:
    - Entrada: "DiseÃ±ar un dashboard de ventas con realidad aumentada."
    - Proceso: Muestra preguntas en VS Code ("Â¿QuÃ© mÃ©tricas debe mostrar el dashboard?", "Â¿QuÃ© tipo de AR prefieres?").
    - Salida: Tareas para **UIDesignAgent**, **DashboardAgent**, **AnalyticsAgent**, y **ComponentAgent** (para AR).
  - **ImplementaciÃ³n**:
    ```typescript
    class QuestionAgent extends BaseAgent {
      private questionTemplate: string;
      private followupQuestions: Map<string, string[]>;

      constructor(config: AgentConfig) {
        super(config);
        this.questionTemplate = this.loadQuestionTemplate();
        this.followupQuestions = this.loadFollowupQuestions();
      }

      async execute(input: string): Promise<AgentResult> {
        const prompt = this.buildQuestionPrompt(input);
        const response = await this.callLLM(prompt);
        const parsedRequirements = this.parseRequirements(response);

        // Cuestionario interactivo en VS Code
        const followups = this.followupQuestions.get(input.toLowerCase()) || [];
        const answers: Record<string, string> = {};
        for (const question of followups) {
          const answer = await vscode.window.showInputBox({ prompt: question });
          answers[question] = answer || '';
        }

        const enrichedRequirements = { ...parsedRequirements, answers };
        await this.saveToMemory(enrichedRequirements, {
          type: 'requirements',
          project: input
        });

        return {
          output: JSON.stringify(enrichedRequirements, null, 2),
          metadata: { requirements: enrichedRequirements }
        };
      }

      private buildQuestionPrompt(input: string): string {
        return `${this.questionTemplate}\nUser Input: ${input}`;
      }

      private parseRequirements(response: string): any {
        return JSON.parse(response);
      }

      private loadQuestionTemplate(): string {
        return "Extract requirements from the following user input:";
      }

      private loadFollowupQuestions(): Map<string, string[]> {
        return new Map([
          ['dashboard', ['What metrics should it display?', 'What style do you prefer?']],
          ['mlm', ['What structure (binary, unilevel, hybrid)?', 'Do you need a store?']],
          ['ar', ['What type of AR (ARKit, ARCore)?', 'What elements should be interactive?']]
        ]);
      }
    }
    ```

- **VisionAgent**
  - **Responsabilidad**: Procesa datos visuales (imÃ¡genes, diagramas) y los convierte en informaciÃ³n accionable, con soporte para cargar imÃ¡genes desde VS Code.
  - **Capacidades**:
    - Analiza wireframes, mockups, o diagramas subidos por el usuario.
    - Genera descripciones textuales (por ejemplo, "Un botÃ³n rojo en la esquina superior derecha").
    - Usa el **EmbeddingService** para generar embeddings de imÃ¡genes y buscar coincidencias en el **Sistema de Memoria**.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Colabora con el **UIDesignAgent** para convertir descripciones en diseÃ±os.
    - Usa el **MemoryAgent** para almacenar imÃ¡genes procesadas y sus descripciones.
    - Permite al usuario cargar imÃ¡genes mediante `vscode.window.showOpenDialog`.
  - **Ejemplo**:
    - Entrada: Imagen de un wireframe cargada desde VS Code.
    - Proceso: Analiza la imagen y genera una descripciÃ³n.
    - Salida: "Barra lateral con 3 opciones: Inicio, Ventas, ConfiguraciÃ³n."
  - **ImplementaciÃ³n**:
    ```typescript
    class VisionAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        // Permitir al usuario seleccionar una imagen en VS Code
        const fileUri = await vscode.window.showOpenDialog({
          canSelectMany: false,
          filters: { 'Images': ['png', 'jpg', 'jpeg'] }
        });

        if (!fileUri || fileUri.length === 0) {
          throw new Error('No image selected');
        }

        const imagePath = fileUri[0].fsPath;
        const imageData = await this.readImage(imagePath);
        const embedding = await this.memory.embeddingService.generateEmbedding(imageData);
        const description = await this.callLLM(`Describe this wireframe: [Image Embedding]`, { embedding });

        await this.saveToMemory({ imagePath, description }, {
          type: 'wireframe',
          project: input
        });

        return {
          output: description,
          metadata: { imagePath, description }
        };
      }

      private async readImage(path: string): Promise<Buffer> {
        return require('fs').promises.readFile(path);
      }
    }
    ```

- **ArchitectAgent**
  - **Responsabilidad**: DiseÃ±a la arquitectura del sistema, con soporte para generar estructuras de carpetas en VS Code.
  - **Capacidades**:
    - Define tecnologÃ­as (por ejemplo, React, Node.js, PostgreSQL).
    - Genera diagramas de arquitectura (por ejemplo, en formato Mermaid).
    - Crea la estructura de carpetas del proyecto usando `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Proporciona arquitectura al **FrontendSyncAgent**, **APIAgent**, y **DatabaseAgent**.
    - Depende del **QuestionAgent** para los requisitos iniciales.
    - Usa el **MemoryAgent** para almacenar la arquitectura.
  - **Ejemplo**:
    - Entrada: "App web con autenticaciÃ³n y realidad aumentada."
    - Salida: Estructura de carpetas (`src/frontend`, `src/backend`), tecnologÃ­as (React, Node.js, ARKit), diagrama de flujo.
  - **ImplementaciÃ³n**:
    ```typescript
    class ArchitectAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const requirements = await this.queryMemory(input);
        const prompt = `Design an architecture for: ${JSON.stringify(requirements)}`;
        const architecture = await this.callLLM(prompt);

        const parsedArchitecture = JSON.parse(architecture);
        const folderStructure = parsedArchitecture.folders;

        // Crear estructura de carpetas en VS Code
        for (const folder of folderStructure) {
          const uri = vscode.Uri.file(`${vscode.workspace.rootPath}/${folder}`);
          await vscode.workspace.fs.createDirectory(uri);
        }

        await this.saveToMemory(parsedArchitecture, {
          type: 'architecture',
          project: input
        });

        return {
          output: JSON.stringify(parsedArchitecture, null, 2),
          metadata: { architecture: parsedArchitecture }
        };
      }
    }
    ```

- **OrchestratorAgent**
  - **Responsabilidad**: Coordina interacciones, gestiona dependencias, y supervisa el flujo de trabajo, con integraciÃ³n en VS Code.
  - **Capacidades**:
    - Mantiene un **grafo dinÃ¡mico de dependencias** usando el **Sistema de Memoria** (Neo4j para relaciones, Faiss para modo offline).
    - Implementa un **TaskManager** para el ciclo de vida de tareas, con estados visibles en VS Code.
    - Resuelve bloqueos y prioriza tareas usando una **PriorityQueue**.
    - Notifica al usuario sobre el estado de las tareas mediante `vscode.window.showInformationMessage`.
  - **Persistencia de Contexto**:
    - Guarda el estado en `cjdevmind.db` y en el almacenamiento local de VS Code (`vscode.Memento`).
    - Checkpoints cada 100 operaciones o 10 minutos.
  - **EjecuciÃ³n AutÃ³noma Supervisada**:
    - Modo simulaciÃ³n para previsualizar acciones.
    - Rollbacks automÃ¡ticos con puntos de restauraciÃ³n (usando el **GitAdapter**).
    - Logs transaccionales para reconstruir el estado.
  - **Interacciones**:
    - Recibe tareas del **QuestionAgent**.
    - Usa el **MemoryAgent** para contexto.
    - Actualiza el **DashboardAgent** con el estado de las tareas.
    - Usa el **VSCodeAgentBridge** para ejecutar agentes en VS Code.
  - **Ejemplo**:
    - Tarea: "Implementar un endpoint de login."
    - AcciÃ³n: Asigna tareas al **APIAgent**, **DatabaseAgent**, **SecurityAgent**, y notifica al usuario en VS Code.
  - **ImplementaciÃ³n**:
    ```typescript
    class OrchestratorAgent extends BaseAgent {
      private taskManager: TaskManager;
      private dependencyGraph: DependencyGraph;
      private priorityQueue: PriorityQueue<Task>;

      constructor(config: AgentConfig) {
        super(config);
        this.taskManager = new TaskManager();
        this.dependencyGraph = new DependencyGraph();
        this.priorityQueue = new PriorityQueue<Task>();
      }

      async execute(input: string): Promise<AgentResult> {
        const tasks = await this.taskManager.createTasks(input);
        for (const task of tasks) {
          this.dependencyGraph.addTask(task);
          this.priorityQueue.enqueue(task, task.priority);
        }

        while (!this.priorityQueue.isEmpty()) {
          const task = this.priorityQueue.dequeue();
          if (this.dependencyGraph.hasUnresolvedDependencies(task)) {
            task.status = 'BLOCKED';
            this.taskManager.updateTask(task);
            continue;
          }

          const agent = AgentFactory.create(task.agent, this.config);
          const result = await agent.execute(task.input);
          task.status = result.success ? 'COMPLETED' : 'ERROR';
          this.taskManager.updateTask(task);

          // Notificar al usuario en VS Code
          vscode.window.showInformationMessage(`Task ${task.id} (${task.agent}): ${task.status}`);
        }

        return {
          output: 'All tasks processed',
          metadata: { tasks: this.taskManager.getTasks() }
        };
      }
    }
    ```

- **ExtensionAgent**
  - **Responsabilidad**: Gestiona extensiones del marketplace, integrado en VS Code, permitiendo la **autoextensiÃ³n** del sistema segÃºn los requerimientos.
  - **Capacidades**:
    - Lista, instala, y configura extensiones desde el marketplace (por ejemplo, plugins de AR, multilenguaje, o temas personalizados).
    - Usa el **PaymentService** para procesar compras con crÃ©ditos.
    - Ejecuta extensiones en un **PluginSandbox** para garantizar seguridad.
    - **AutoextensiÃ³n**: Permite aÃ±adir nuevas funcionalidades al sistema (como soporte para AR o nuevas herramientas de testing) instalando extensiones, lo que funcionalmente puede equivaler a "nuevos agentes" en tÃ©rminos de capacidades, aunque no crea agentes nuevos en la jerarquÃ­a.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **IntegrationAgent** para conectar con la **MarketplaceAPI**.
    - Colabora con el **DashboardAgent** para mostrar extensiones disponibles.
    - Usa el **VSCodeMarketplaceBridge** para integrarse con el marketplace oficial de VS Code.
  - **Modelo de Negocio**:
    - Gestiona compras con crÃ©ditos (por ejemplo, 50 crÃ©ditos por un plugin de AR).
    - Restringe acceso segÃºn la licencia (Community: limitado, Professional/Enterprise: completo).
  - **Ejemplo**:
    - Entrada: "Instalar extensiÃ³n de realidad aumentada para un sistema MLM."
    - Salida: ExtensiÃ³n instalada y configurada, con notificaciÃ³n en VS Code, permitiendo que agentes como **ComponentAgent** generen componentes AR.
  - **ImplementaciÃ³n**:
    ```typescript
    class ExtensionAgent extends BaseAgent {
      private marketplaceAPI: MarketplaceAPI;

      constructor(config: AgentConfig) {
        super(config);
        this.marketplaceAPI = new MarketplaceAPI(config.marketplaceConfig);
      }

      async execute(input: string): Promise<AgentResult> {
        const plugins = await this.marketplaceAPI.listPlugins({ category: input });
        const pluginNames = plugins.map(p => p.name);

        // Mostrar lista de plugins en VS Code
        const selectedPlugin = await vscode.window.showQuickPick(pluginNames, {
          placeHolder: 'Select a plugin to install'
        });

        if (!selectedPlugin) {
          throw new Error('No plugin selected');
        }

        const plugin = plugins.find(p => p.name === selectedPlugin);
        const installResult = await this.marketplaceAPI.installPlugin(plugin.id);

        await this.saveToMemory({ plugin: plugin.name, installResult }, {
          type: 'extension',
          project: input
        });

        return {
          output: `Plugin ${plugin.name} installed successfully`,
          metadata: { installResult }
        };
      }
    }
    ```

#### 2. Frontend (Interfaz de Usuario)

- **UIDesignAgent**
  - **Responsabilidad**: DiseÃ±a interfaces de usuario, con soporte para previsualizaciÃ³n en VS Code.
  - **Capacidades**:
    - Genera sistemas de diseÃ±o (colores, tipografÃ­a, espaciado).
    - Aplica principios de UX y accesibilidad (WCAG).
    - Muestra previsualizaciones en un webview de VS Code.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **VisionAgent** para descripciones de wireframes.
    - Pasa diseÃ±os al **LayoutAgent** y al **StyleAgent**.
    - Usa el **MemoryAgent** para almacenar sistemas de diseÃ±o.
    - Colabora con el **StyleAgent** para aplicar temas y estilos consistentes.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar sus prompts y diseÃ±os.
  - **Ejemplo**:
    - Entrada: "DiseÃ±ar un dashboard con tema oscuro."
    - Salida: Sistema de diseÃ±o (colores: negro/gris, tipografÃ­a: Roboto), previsualizaciÃ³n en VS Code.
  - **ImplementaciÃ³n**:
    ```typescript
    class UIDesignAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const prompt = `Design a UI system for: ${input}`;
        const designSystem = await this.callLLM(prompt);
        const parsedDesign = JSON.parse(designSystem);

        // Mostrar previsualizaciÃ³n en un webview de VS Code
        const htmlContent = `
          <html>
          <body style="background: ${parsedDesign.colors.background}; color: ${parsedDesign.colors.text}">
            <h1>Preview</h1>
            <p>Typography: ${parsedDesign.typography}</p>
            <button style="background: ${parsedDesign.colors.primary}">Sample Button</button>
          </body>
          </html>
        `;
        await this.vscodeAdapter.showWebview('ui-preview', htmlContent);

        await this.saveToMemory(parsedDesign, {
          type: 'design-system',
          project: input
        });

        return {
          output: JSON.stringify(parsedDesign, null, 2),
          metadata: { designSystem: parsedDesign }
        };
      }
    }
    ```

- **LayoutAgent**
  - **Responsabilidad**: Convierte diseÃ±os en layouts (HTML/CSS, React), con soporte para generar archivos en VS Code.
  - **Capacidades**:
    - Genera cÃ³digo responsive (usando CSS Grid, Flexbox).
    - Usa frameworks definidos por el **ArchitectAgent** (por ejemplo, React, Tailwind CSS).
    - Escribe archivos en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ BLOCKED (si diseÃ±o no estÃ¡ listo) â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **UIDesignAgent** para el sistema de diseÃ±o.
    - Colabora con el **ComponentAgent** para integrar componentes.
    - Usa el **StyleAgent** para aplicar estilos consistentes.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de layouts.
  - **Ejemplo**:
    - Entrada: DiseÃ±o de un dashboard.
    - Salida: Archivo `DashboardLayout.jsx` con un layout de grid, creado en `src/layouts`.
  - **ImplementaciÃ³n**:
    ```typescript
    class LayoutAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const designSystem = await this.queryMemory(input);
        const prompt = `Generate a responsive layout for: ${JSON.stringify(designSystem)}`;
        const layoutCode = await this.callLLM(prompt);

        // Escribir archivo en el proyecto
        const filePath = `${vscode.workspace.rootPath}/src/layouts/DashboardLayout.jsx`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(layoutCode, 'utf8'));

        await this.saveToMemory({ filePath, code: layoutCode }, {
          type: 'layout',
          project: input
        });

        return {
          output: `Layout generated at ${filePath}`,
          metadata: { filePath, code: layoutCode }
        };
      }
    }
    ```

- **ComponentAgent (Actualizado)**
  - **Responsabilidad**: Crea componentes reutilizables, con soporte para generar archivos en VS Code y mejoras en accesibilidad y documentaciÃ³n.
  - **Capacidades**:
    - Genera componentes modulares (por ejemplo, botones, formularios) en mÃºltiples frameworks (React, Vue, Angular, Svelte).
    - Aplica estilos consistentes basados en el sistema de diseÃ±o del **UIDesignAgent**.
    - Asegura accesibilidad (WCAG AA) y genera estados (hover, focus, disabled).
    - Escribe archivos en el proyecto del usuario mediante `vscode.workspace.fs`.
    - Genera documentaciÃ³n automÃ¡tica (JSDoc/TSDoc) y ejemplos de uso.
    - Puede aprovechar extensiones instaladas por el **ExtensionAgent** (por ejemplo, para soportar AR o multilenguaje).
  - **Persistencia de Contexto**:
    - Guarda componentes en el **MemoryAgent** para reutilizaciÃ³n.
  - **Interacciones**:
    - Trabaja con el **LayoutAgent** para integrar componentes.
    - Depende del **UIDesignAgent** y del **StyleAgent** para estilos.
    - Colabora con el **CodeReviewAgent** para revisiones de calidad.
    - Usa el **TestAgent** para generar pruebas automatizadas de los componentes.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de componentes.
  - **Ejemplo**:
    - Entrada: "Crear un botÃ³n de login con tema oscuro en React."
    - Salida: Componente `<LoginButton />` en `src/components/LoginButton.tsx`, con documentaciÃ³n y ejemplo de uso.
  - **ImplementaciÃ³n**:
    ```typescript
    class ComponentAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const designSystem = await this.queryMemory('design-system');
        const prompt = `Generate a reusable component for: ${input}, using design system: ${JSON.stringify(designSystem)}`;
        const componentCode = await this.callLLM(prompt);

        // Escribir archivo en el proyecto
        const filePath = `${vscode.workspace.rootPath}/src/components/LoginButton.tsx`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(componentCode, 'utf8'));

        // Generar documentaciÃ³n
        const docPath = `${vscode.workspace.rootPath}/src/components/LoginButton.md`;
        const docUri = vscode.Uri.file(docPath);
        const docContent = `## LoginButton\n\n### Props\n- **label**: string\n- **onClick**: () => void\n\n### Example\n\`\`\`tsx\n<LoginButton label="Login" onClick={() => console.log('Clicked')} />\n\`\`\``;
        await vscode.workspace.fs.writeFile(docUri, Buffer.from(docContent, 'utf8'));

        await this.saveToMemory({ filePath, code: componentCode, docPath, docContent }, {
          type: 'component',
          project: input
        });

        // Notificar a CodeReviewAgent y TestAgent
        this.publishEvent('component-created', { filePath, code: componentCode }, 'calidad');

        return {
          output: `Component generated at ${filePath}`,
          metadata: { filePath, code: componentCode, docPath, docContent }
        };
      }
    }
    ```

- **FrontendSyncAgent**
  - **Responsabilidad**: Sincroniza frontend con backend, con soporte para generar cÃ³digo en VS Code.
  - **Capacidades**:
    - Genera cÃ³digo para solicitudes HTTP (usando `fetch` o `axios`).
    - Gestiona estados (React hooks, Redux).
    - Escribe archivos en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ BLOCKED (si APIs no estÃ¡n listas) â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **APIAgent** para obtener endpoints.
    - Colabora con el **ComponentAgent** para integrar componentes.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la sincronizaciÃ³n.
  - **Ejemplo**:
    - Entrada: "Conectar un formulario de login a una API."
    - Salida: CÃ³digo en `src/services/auth.js` para enviar datos a `/login`.
  - **ImplementaciÃ³n**:
    ```typescript
    class FrontendSyncAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const apiEndpoints = await this.queryMemory('api-endpoints');
        const prompt = `Generate frontend sync code for: ${input}, using endpoints: ${JSON.stringify(apiEndpoints)}`;
        const syncCode = await this.callLLM(prompt);

        // Escribir archivo en el proyecto
        const filePath = `${vscode.workspace.rootPath}/src/services/auth.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(syncCode, 'utf8'));

        await this.saveToMemory({ filePath, code: syncCode }, {
          type: 'frontend-sync',
          project: input
        });

        return {
          output: `Frontend sync code generated at ${filePath}`,
          metadata: { filePath, code: syncCode }
        };
      }
    }
    ```

- **StyleAgent (Nuevo)**
  - **Responsabilidad**: Gestiona temas y estilos visuales, asegurando consistencia en el frontend.
  - **Capacidades**:
    - Aplica temas (claro, oscuro, personalizado) basados en el sistema de diseÃ±o del **UIDesignAgent**.
    - Genera variables CSS y configuraciones Tailwind para mantener consistencia visual.
    - Gestiona transiciones de estilo (por ejemplo, cambio de tema dinÃ¡mico).
    - Escribe archivos de estilo en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **UIDesignAgent** para el sistema de diseÃ±o y temas.
    - Colabora con el **ComponentAgent** y el **LayoutAgent** para aplicar estilos.
    - Usa el **MemoryAgent** para almacenar configuraciones de estilo.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de estilos.
  - **Ejemplo**:
    - Entrada: "Aplicar un tema oscuro a un dashboard."
    - Salida: Archivo `src/styles/theme-dark.css` con variables CSS y configuraciÃ³n Tailwind actualizada.
  - **ImplementaciÃ³n**:
    ```typescript
    class StyleAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const designSystem = await this.queryMemory('design-system');
        const prompt = `Generate styles for: ${input}, using design system: ${JSON.stringify(designSystem)}`;
        const styleCode = await this.callLLM(prompt);

        // Escribir archivo de estilos
        const filePath = `${vscode.workspace.rootPath}/src/styles/theme-dark.css`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(styleCode, 'utf8'));

        // Actualizar configuraciÃ³n Tailwind
        const tailwindConfigPath = `${vscode.workspace.rootPath}/tailwind.config.js`;
        const tailwindConfigUri = vscode.Uri.file(tailwindConfigPath);
        const tailwindConfig = await this.updateTailwindConfig(designSystem);
        await vscode.workspace.fs.writeFile(tailwindConfigUri, Buffer.from(tailwindConfig, 'utf8'));

        await this.saveToMemory({ filePath, code: styleCode, tailwindConfigPath, tailwindConfig }, {
          type: 'style',
          project: input
        });

        return {
          output: `Styles generated at ${filePath}`,
          metadata: { filePath, code: styleCode, tailwindConfigPath, tailwindConfig }
        };
      }

      private async updateTailwindConfig(designSystem: any): Promise<string> {
        const colors = designSystem.colors || {};
        return `
          module.exports = {
            theme: {
              extend: {
                colors: ${JSON.stringify(colors, null, 2)}
              }
            }
          };
        `;
      }
    }
    ```

#### 3. Backend (LÃ³gica y Datos)

- **APIAgent**
  - **Responsabilidad**: DiseÃ±a e implementa APIs, con soporte para generar archivos en VS Code.
  - **Capacidades**:
    - Genera endpoints con validaciones (usando Express, FastAPI).
    - Implementa middleware para autenticaciÃ³n y logging.
    - Escribe archivos en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **EjecuciÃ³n AutÃ³noma Supervisada**:
    - Crea puntos de restauraciÃ³n (usando el **GitAdapter**) y logs transaccionales antes de cambios.
  - **Interacciones**:
    - Depende del **ArchitectAgent** para la arquitectura.
    - Colabora con el **DatabaseAgent** para esquemas.
    - Pasa endpoints al **FrontendSyncAgent**.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de endpoints.
  - **Ejemplo**:
    - Entrada: "Crear un endpoint para registrar usuarios."
    - Salida: Endpoint `/register` en `src/backend/routes/auth.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class APIAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const architecture = await this.queryMemory('architecture');
        const prompt = `Generate an API endpoint for: ${input}, using framework: ${architecture.backendFramework}`;
        const endpointCode = await this.callLLM(prompt);

        // Crear punto de restauraciÃ³n
        const gitAdapter = new GitAdapter(vscode.workspace.rootPath);
        await gitAdapter.commit(`Pre-API change: ${input}`);

        // Escribir archivo en el proyecto
        const filePath = `${vscode.workspace.rootPath}/src/backend/routes/auth.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(endpointCode, 'utf8'));

        await this.saveToMemory({ filePath, code: endpointCode }, {
          type: 'api-endpoint',
          project: input
        });

        return {
          output: `Endpoint generated at ${filePath}`,
          metadata: { filePath, code: endpointCode }
        };
      }
    }
    ```

- **LogicAgent**
  - **Responsabilidad**: Implementa lÃ³gica de negocio, con soporte para generar archivos en VS Code.
  - **Capacidades**:
    - Escribe funciones para reglas de negocio (por ejemplo, cÃ¡lculo de comisiones MLM).
    - Optimiza lÃ³gica para mejorar rendimiento.
    - Escribe archivos en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ ERROR (si falla un test) â†’ IN_PROGRESS â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **APIAgent** para integrarse con endpoints.
    - Trabaja con el **TestingAgent** y el **TestAgent** para validar lÃ³gica.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la lÃ³gica generada.
  - **Ejemplo**:
    - Entrada: "Calcular el total de una orden en un sistema MLM."
    - Salida: FunciÃ³n `calculateOrderTotal()` en `src/backend/logic/orders.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class LogicAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const prompt = `Generate business logic for: ${input}`;
        const logicCode = await this.callLLM(prompt);

        // Escribir archivo en el proyecto
        const filePath = `${vscode.workspace.rootPath}/src/backend/logic/orders.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(logicCode, 'utf8'));

        await this.saveToMemory({ filePath, code: logicCode }, {
          type: 'business-logic',
          project: input
        });

        return {
          output: `Logic generated at ${filePath}`,
          metadata: { filePath, code: logicCode }
        };
      }
    }
    ```

- **DatabaseAgent**
  - **Responsabilidad**: Gestiona esquemas y migraciones, con soporte para generar archivos en VS Code.
  - **Capacidades**:
    - DiseÃ±a esquemas de bases de datos (PostgreSQL, MySQL).
    - Genera migraciones para cambios en el esquema.
    - Escribe archivos de migraciÃ³n en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Persistencia de Contexto**:
    - Guarda esquemas y migraciones en el **MemoryAgent**.
  - **Interacciones**:
    - Depende del **ArchitectAgent** para la arquitectura.
    - Proporciona esquemas al **APIAgent**.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de esquemas.
  - **Ejemplo**:
    - Entrada: "Crear una tabla de usuarios para un sistema MLM."
    - Salida: Esquema SQL para `users` en `src/backend/migrations/001_create_users.sql`.
  - **ImplementaciÃ³n**:
    ```typescript
    class DatabaseAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const architecture = await this.queryMemory('architecture');
        const prompt = `Generate a database schema for: ${input}, using database: ${architecture.database}`;
        const schemaCode = await this.callLLM(prompt);

        // Escribir archivo de migraciÃ³n
        const filePath = `${vscode.workspace.rootPath}/src/backend/migrations/001_create_users.sql`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(schemaCode, 'utf8'));

        await this.saveToMemory({ filePath, code: schemaCode }, {
          type: 'database-schema',
          project: input
        });

        return {
          output: `Schema generated at ${filePath}`,
          metadata: { filePath, code: schemaCode }
        };
      }
    }
    ```

- **IntegrationAgent**
  - **Responsabilidad**: Integra servicios externos, con soporte para gestionar claves en VS Code.
  - **Capacidades**:
    - Configura integraciones con servicios externos (OAuth, Stripe, ARKit).
    - Gestiona claves API de forma segura usando `vscode.SecretStorage`.
    - Genera cÃ³digo para interactuar con APIs externas.
  - **Interacciones**:
    - Depende del **SecurityAgent** para validar integraciones.
    - Colabora con el **APIAgent** para conectar endpoints.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar las integraciones.
  - **Ejemplo**:
    - Entrada: "Integrar Stripe para pagos en un sistema MLM."
    - Salida: CÃ³digo para manejar pagos en `src/backend/integrations/stripe.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class IntegrationAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const prompt = `Generate integration code for: ${input}`;
        const integrationCode = await this.callLLM(prompt);

        // Almacenar clave API de forma segura
        const stripeKey = await vscode.window.showInputBox({ prompt: 'Enter your Stripe API key', password: true });
        await this.vscodeAdapter.storeSecret('stripe-api-key', stripeKey);

        // Escribir archivo de integraciÃ³n
        const filePath = `${vscode.workspace.rootPath}/src/backend/integrations/stripe.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(integrationCode, 'utf8'));

        await this.saveToMemory({ filePath, code: integrationCode }, {
          type: 'integration',
          project: input
        });

        return {
          output: `Integration generated at ${filePath}`,
          metadata: { filePath, code: integrationCode }
        };
      }
    }
    ```

#### 4. Calidad (Aseguramiento y OptimizaciÃ³n)

- **TestingAgent**
  - **Responsabilidad**: Escribe y ejecuta pruebas, con soporte para generar archivos de prueba en VS Code.
  - **Capacidades**:
    - Genera pruebas unitarias e integrales (Jest, Pytest).
    - Reporta errores y cobertura de pruebas.
    - Escribe archivos de prueba en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ ERROR (si falla) â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **APIAgent** y **LogicAgent** para probar cÃ³digo.
    - Notifica al **OrchestratorAgent** sobre resultados.
    - Colabora con el **TestAgent** para pruebas mÃ¡s especializadas.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de pruebas.
  - **Ejemplo**:
    - Entrada: "Probar un endpoint de login."
    - Salida: Pruebas Jest en `src/backend/tests/auth.test.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class TestingAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const codeToTest = await this.queryMemory('api-endpoint');
        const prompt = `Generate tests for: ${input}, using code: ${JSON.stringify(codeToTest)}`;
        const testCode = await this.callLLM(prompt);

        // Escribir archivo de pruebas
        const filePath = `${vscode.workspace.rootPath}/src/backend/tests/auth.test.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(testCode, 'utf8'));

        await this.saveToMemory({ filePath, code: testCode }, {
          type: 'tests',
          project: input
        });

        return {
          output: `Tests generated at ${filePath}`,
          metadata: { filePath, code: testCode }
        };
      }
    }
    ```

- **SecurityAgent**
  - **Responsabilidad**: Analiza vulnerabilidades y aplica medidas de seguridad, con soporte para VS Code.
  - **Capacidades**:
    - Detecta vulnerabilidades (SQL injection, XSS).
    - Aplica JWT, encriptaciÃ³n, y sanitizaciÃ³n de entradas.
    - Usa `vscode.SecretStorage` para gestionar claves.
  - **EjecuciÃ³n AutÃ³noma Supervisada**:
    - Crea rollbacks automÃ¡ticos antes de aplicar parches.
    - Registra logs transaccionales.
  - **Interacciones**:
    - Valida integraciones del **IntegrationAgent**.
    - Trabaja con el **APIAgent** para asegurar endpoints.
    - Colabora con el **CodeReviewAgent** para revisiones de seguridad.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar las medidas de seguridad.
  - **Ejemplo**:
    - Entrada: "Asegurar un endpoint de login."
    - Salida: JWT y validaciÃ³n de entradas en `src/backend/middleware/security.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class SecurityAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const endpointCode = await this.queryMemory('api-endpoint');
        const prompt = `Secure the following endpoint: ${JSON.stringify(endpointCode)}`;
        const securityCode = await this.callLLM(prompt);

        // Crear punto de restauraciÃ³n
        const gitAdapter = new GitAdapter(vscode.workspace.rootPath);
        await gitAdapter.commit(`Pre-security change: ${input}`);

        // Escribir archivo de seguridad
        const filePath = `${vscode.workspace.rootPath}/src/backend/middleware/security.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(securityCode, 'utf8'));

        await this.saveToMemory({ filePath, code: securityCode }, {
          type: 'security',
          project: input
        });

        return {
          output: `Security measures applied at ${filePath}`,
          metadata: { filePath, code: securityCode }
        };
      }
    }
    ```

- **PerformanceAgent**
  - **Responsabilidad**: Optimiza rendimiento, con soporte para generar recomendaciones en VS Code.
  - **Capacidades**:
    - Analiza tiempos de carga y uso de recursos.
    - Propone mejoras (indexaciÃ³n, caching).
    - Muestra recomendaciones en VS Code mediante `vscode.window.showInformationMessage`.
  - **Interacciones**:
    - Depende del **MonitorAgent** para mÃ©tricas.
    - Colabora con el **DatabaseAgent** para optimizar consultas.
    - Usa el **SelfImprovementAgent** para optimizar su propio anÃ¡lisis.
  - **Ejemplo**:
    - Entrada: "Optimizar una consulta a la tabla de usuarios."
    - Salida: RecomendaciÃ³n de Ã­ndices en `src/backend/optimizations/users_index.sql`.
  - **ImplementaciÃ³n**:
    ```typescript
    class PerformanceAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const metrics = await this.queryMemory('performance-metrics');
        const prompt = `Optimize performance for: ${input}, using metrics: ${JSON.stringify(metrics)}`;
        const optimization = await this.callLLM(prompt);

        // Escribir archivo de optimizaciÃ³n
        const filePath = `${vscode.workspace.rootPath}/src/backend/optimizations/users_index.sql`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(optimization, 'utf8'));

        // Mostrar recomendaciÃ³n en VS Code
        vscode.window.showInformationMessage(`Performance optimization generated at ${filePath}`);

        await this.saveToMemory({ filePath, code: optimization }, {
          type: 'optimization',
          project: input
        });

        return {
          output: `Optimization generated at ${filePath}`,
          metadata: { filePath, code: optimization }
        };
      }
    }
    ```

- **RefactorAgent**
  - **Responsabilidad**: Refactoriza cÃ³digo para mejorar calidad, con soporte para VS Code.
  - **Capacidades**:
    - Reorganiza cÃ³digo para mayor claridad.
    - Aplica patrones de diseÃ±o (por ejemplo, Factory, Singleton).
    - Escribe archivos refactorizados en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Persistencia de Contexto**:
    - Guarda versiones anteriores en el **MemoryAgent**.
  - **Interacciones**:
    - Trabaja con el **TestingAgent** y el **TestAgent** para validar refactorizaciones.
    - Depende del **LogicAgent** para identificar cÃ³digo a refactorizar.
    - Colabora con el **CodeReviewAgent** para revisiones.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar las refactorizaciones.
  - **Ejemplo**:
    - Entrada: "Refactorizar una funciÃ³n de cÃ¡lculo de comisiones MLM."
    - Salida: CÃ³digo refactorizado en `src/backend/logic/commissions.js`.
  - **ImplementaciÃ³n**:
    ```typescript
    class RefactorAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const codeToRefactor = await this.queryMemory('business-logic');
        const prompt = `Refactor the following code: ${JSON.stringify(codeToRefactor)}`;
        const refactoredCode = await this.callLLM(prompt);

        // Escribir archivo refactorizado
        const filePath = `${vscode.workspace.rootPath}/src/backend/logic/commissions.js`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(refactoredCode, 'utf8'));

        await this.saveToMemory({ filePath, code: refactoredCode }, {
          type: 'refactored-code',
          project: input
        });

        return {
          output: `Code refactored at ${filePath}`,
          metadata: { filePath, code: refactoredCode }
        };
      }
    }
    ```

- **TestAgent (Nuevo)**
  - **Responsabilidad**: Genera pruebas automatizadas especializadas para componentes y layouts, con soporte para VS Code.
  - **Capacidades**:
    - Genera pruebas de accesibilidad (WCAG AA) y pruebas visuales (por ejemplo, snapshots con Storybook).
    - Escribe pruebas para estados de componentes (hover, focus, disabled).
    - Escribe archivos de prueba en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ ERROR (si falla) â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **ComponentAgent** y **LayoutAgent** para probar componentes y layouts.
    - Colabora con el **TestingAgent** para pruebas mÃ¡s generales.
    - Usa el **CodeReviewAgent** para validar la calidad de las pruebas.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la generaciÃ³n de pruebas.
  - **Ejemplo**:
    - Entrada: "Probar accesibilidad de un botÃ³n de login."
    - Salida: Pruebas Jest con axe-core en `src/components/tests/LoginButton.test.tsx`.
  - **ImplementaciÃ³n**:
    ```typescript
    class TestAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const componentCode = await this.queryMemory('component');
        const prompt = `Generate accessibility and visual tests for: ${input}, using code: ${JSON.stringify(componentCode)}`;
        const testCode = await this.callLLM(prompt);

        // Escribir archivo de pruebas
        const filePath = `${vscode.workspace.rootPath}/src/components/tests/LoginButton.test.tsx`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(testCode, 'utf8'));

        await this.saveToMemory({ filePath, code: testCode }, {
          type: 'specialized-tests',
          project: input
        });

        return {
          output: `Specialized tests generated at ${filePath}`,
          metadata: { filePath, code: testCode }
        };
      }
    }
    ```

- **SelfImprovementAgent (Nuevo)**
  - **Responsabilidad**: Optimiza el cÃ³digo y el comportamiento de otros agentes, permitiendo la **automejora** del sistema segÃºn los requerimientos, con soporte para VS Code.
  - **Capacidades**:
    - Analiza el historial de ejecuciÃ³n de agentes para identificar ineficiencias.
    - Propone mejoras en prompts, lÃ³gica, o configuraciones (por ejemplo, ajusta prompts del **UIDesignAgent** para generar mejores diseÃ±os).
    - Escribe archivos de configuraciÃ³n optimizados en el proyecto del usuario mediante `vscode.workspace.fs`.
    - **Automejora**: Adapta dinÃ¡micamente el comportamiento de los agentes para cumplir con los requerimientos del proyecto, mejorando su rendimiento y precisiÃ³n.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Usa el **MemoryAgent** para acceder al historial de ejecuciÃ³n.
    - Colabora con todos los agentes para optimizar su comportamiento.
    - Notifica al **OrchestratorAgent** sobre mejoras implementadas.
  - **Ejemplo**:
    - Entrada: "Optimizar el rendimiento del UIDesignAgent."
    - Salida: Nueva configuraciÃ³n de prompts en `src/config/ui-design-agent-prompts.json`.
  - **ImplementaciÃ³n**:
    ```typescript
    class SelfImprovementAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const executionHistory = await this.queryMemory('execution-history');
        const prompt = `Analyze and optimize agent performance for: ${input}, using history: ${JSON.stringify(executionHistory)}`;
        const optimization = await this.callLLM(prompt);

        // Escribir archivo de configuraciÃ³n optimizada
        const filePath = `${vscode.workspace.rootPath}/src/config/ui-design-agent-prompts.json`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(optimization, 'utf8'));

        await this.saveToMemory({ filePath, code: optimization }, {
          type: 'agent-optimization',
          project: input
        });

        // Notificar al OrchestratorAgent
        this.publishEvent('agent-optimized', { agent: input, optimization }, 'meta');

        return {
          output: `Agent optimization generated at ${filePath}`,
          metadata: { filePath, code: optimization }
        };
      }
    }
    ```

- **CodeReviewAgent (Nuevo)**
  - **Responsabilidad**: Revisa cÃ³digo generado por otros agentes para asegurar calidad y consistencia, con soporte para VS Code.
  - **Capacidades**:
    - Analiza cÃ³digo en busca de errores, problemas de accesibilidad, y violaciones de mejores prÃ¡cticas.
    - Propone correcciones y mejoras (por ejemplo, optimizaciÃ³n de rendimiento, mejor legibilidad).
    - Muestra revisiones en VS Code mediante `vscode.window.showInformationMessage`.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **ComponentAgent**, **APIAgent**, y otros agentes para revisar su cÃ³digo.
    - Colabora con the **TestAgent** para validar que las correcciones pasen las pruebas.
    - Usa el **MemoryAgent** para almacenar revisiones y correcciones.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar sus revisiones.
  - **Ejemplo**:
    - Entrada: "Revisar un componente de login."
    - Salida: Informe de revisiÃ³n con correcciones en `src/components/LoginButton.tsx`.
  - **ImplementaciÃ³n**:
    ```typescript
    class CodeReviewAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const codeToReview = await this.queryMemory('component');
        const prompt = `Review the following code for quality and accessibility: ${JSON.stringify(codeToReview)}`;
        const reviewReport = await this.callLLM(prompt);

        // Aplicar correcciones
        const filePath = `${vscode.workspace.rootPath}/src/components/LoginButton.tsx`;
        const uri = vscode.Uri.file(filePath);
        const correctedCode = this.applyCorrections(codeToReview.code, reviewReport);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(correctedCode, 'utf8'));

        // Mostrar informe en VS Code
        vscode.window.showInformationMessage(`Code review completed: ${reviewReport.summary}`);

        await this.saveToMemory({ filePath, code: correctedCode, reviewReport }, {
          type: 'code-review',
          project: input
        });

        return {
          output: `Code review completed at ${filePath}`,
          metadata: { filePath, code: correctedCode, reviewReport }
        };
      }

      private applyCorrections(originalCode: string, reviewReport: any): string {
        // SimulaciÃ³n de aplicaciÃ³n de correcciones
        return originalCode + `\n// Correcciones aplicadas: ${reviewReport.corrections}`;
      }
    }
    ```

#### 5. Infraestructura (Despliegue y Monitoreo)

- **DevOpsAgent**
  - **Responsabilidad**: Gestiona despliegues y CI/CD, con soporte para VS Code.
  - **Capacidades**:
    - Configura pipelines (GitHub Actions, Jenkins).
    - Gestiona entornos (desarrollo, producciÃ³n).
    - Usa el **GitAdapter** para commits y rollbacks.
  - **EjecuciÃ³n AutÃ³noma Supervisada**:
    - Crea rollbacks automÃ¡ticos y logs transaccionales.
  - **Interacciones**:
    - Depende del **MonitorAgent** para mÃ©tricas de despliegue.
    - Colabora con el **DashboardAgent** para mostrar el estado del despliegue.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar los pipelines.
  - **Ejemplo**:
    - Entrada: "Desplegar una app MLM en producciÃ³n."
    - Salida: Pipeline configurado en `.github/workflows/deploy.yml`.
  - **ImplementaciÃ³n**:
    ```typescript
    class DevOpsAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const prompt = `Generate a CI/CD pipeline for: ${input}`;
        const pipelineCode = await this.callLLM(prompt);

        // Crear punto de restauraciÃ³n
        const gitAdapter = new GitAdapter(vscode.workspace.rootPath);
        await gitAdapter.commit(`Pre-deployment: ${input}`);

        // Escribir archivo de pipeline
        const filePath = `${vscode.workspace.rootPath}/.github/workflows/deploy.yml`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(pipelineCode, 'utf8'));

        await this.saveToMemory({ filePath, code: pipelineCode }, {
          type: 'pipeline',
          project: input
        });

        return {
          output: `Pipeline generated at ${filePath}`,
          metadata: { filePath, code: pipelineCode }
        };
      }
    }
    ```

- **MonitorAgent**
  - **Responsabilidad**: Recolecta mÃ©tricas, con soporte para VS Code.
  - **Capacidades**:
    - Registra mÃ©tricas (uso de CPU, tiempos de respuesta).
    - Genera alertas para problemas (por ejemplo, alta latencia).
    - Muestra mÃ©tricas en el dashboard de VS Code.
  - **Persistencia de Contexto**:
    - Guarda mÃ©tricas en el **MemoryAgent**.
  - **Interacciones**:
    - Proporciona datos al **PerformanceAgent**.
    - Actualiza el **DashboardAgent** con mÃ©tricas.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la recolecciÃ³n de mÃ©tricas.
  - **Ejemplo**:
    - Entrada: "Monitorear una API de login."
    - Salida: MÃ©tricas de respuesta (latencia: 200ms, uso de CPU: 5%).
  - **ImplementaciÃ³n**:
    ```typescript
    class MonitorAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const metrics = await this.collectMetrics(input);
        await this.saveToMemory(metrics, {
          type: 'metrics',
          project: input
        });

        // Publicar evento para el DashboardAgent
        this.publishEvent('metrics-update', metrics, 'infrastructure');

        return {
          output: JSON.stringify(metrics, null, 2),
          metadata: { metrics }
        };
      }

      private async collectMetrics(input: string): Promise<any> {
        // SimulaciÃ³n de recolecciÃ³n de mÃ©tricas
        return {
          latency: 200,
          cpuUsage: 5,
          timestamp: Date.now()
        };
      }
    }
    ```

- **DashboardAgent**
  - **Responsabilidad**: Mantiene el dashboard de supervisiÃ³n, renderizado en VS Code.
  - **Capacidades**:
    - Muestra estados de tareas, mÃ©tricas de ROI, y saldo de crÃ©ditos.
    - Integra el marketplace para comprar extensiones.
    - Usa un webview de VS Code para renderizar el dashboard.
  - **Interacciones**:
    - Depende del **OrchestratorAgent** para el estado de las tareas.
    - Usa datos del **MonitorAgent** y **AnalyticsAgent**.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la visualizaciÃ³n.
  - **Ejemplo**:
    - Entrada: "Crear dashboard de supervisiÃ³n."
    - Salida: Webview en VS Code mostrando tareas, mÃ©tricas, y opciones de compra.
  - **ImplementaciÃ³n**:
    ```typescript
    class DashboardAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const tasks = await this.queryMemory('tasks');
        const metrics = await this.queryMemory('metrics');
        const license = await this.queryMemory('license');

        const htmlContent = `
          <html>
          <body>
            <h1>CJ.DevMind Dashboard</h1>
            <h2>Tasks</h2>
            <pre>${JSON.stringify(tasks, null, 2)}</pre>
            <h2>Metrics</h2>
            <pre>${JSON.stringify(metrics, null, 2)}</pre>
            <h2>License</h2>
            <pre>${JSON.stringify(license, null, 2)}</pre>
          </body>
          </html>
        `;

        await this.vscodeAdapter.showWebview('dashboard', htmlContent);

        return {
          output: 'Dashboard rendered in VS Code',
          metadata: { tasks, metrics, license }
        };
      }
    }
    ```

- **AnalyticsAgent**
  - **Responsabilidad**: Analiza datos y genera reportes, con soporte para VS Code.
  - **Capacidades**:
    - Calcula ROI basado en mÃ©tricas de proyecto.
    - Genera reportes (por ejemplo, costos vs. beneficios).
    - Muestra reportes en el dashboard de VS Code.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **MonitorAgent** para mÃ©tricas.
    - Actualiza el **DashboardAgent** con reportes.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar los reportes.
  - **Ejemplo**:
    - Entrada: "Calcular ROI de un sistema MLM."
    - Salida: Reporte (inversiÃ³n: $5000, retorno proyectado: $15000).
  - **ImplementaciÃ³n**:
    ```typescript
    class AnalyticsAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const metrics = await this.queryMemory('metrics');
        const prompt = `Calculate ROI for: ${input}, using metrics: ${JSON.stringify(metrics)}`;
        const report = await this.callLLM(prompt);

        await this.saveToMemory(report, {
          type: 'analytics-report',
          project: input
        });

        // Publicar evento para el DashboardAgent
        this.publishEvent('report-update', report, 'infrastructure');

        return {
          output: JSON.stringify(report, null, 2),
          metadata: { report }
        };
      }
    }
    ```

#### 6. DocumentaciÃ³n (Registro y Contexto)

- **DocAgent**
  - **Responsabilidad**: Genera documentaciÃ³n, con soporte para VS Code.
  - **Capacidades**:
    - Crea documentaciÃ³n de APIs (Swagger, Markdown).
    - Genera guÃ­as de usuario y tÃ©cnicas.
    - Escribe archivos de documentaciÃ³n en el proyecto del usuario mediante `vscode.workspace.fs`.
  - **Persistencia de Contexto**:
    - Guarda versiones de documentaciÃ³n en el **MemoryAgent**.
  - **Interacciones**:
    - Depende del **APIAgent** para documentar endpoints.
    - Colabora con el **MemoryAgent** para almacenar documentaciÃ³n.
    - Usa el **CodeReviewAgent** para validar la calidad de la documentaciÃ³n.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar la documentaciÃ³n.
  - **Ejemplo**:
    - Entrada: "Documentar un endpoint de registro."
    - Salida: Archivo Markdown `docs/api/register.md`.
  - **ImplementaciÃ³n**:
    ```typescript
    class DocAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const endpoint = await this.queryMemory('api-endpoint');
        const prompt = `Generate documentation for: ${JSON.stringify(endpoint)}`;
        const docContent = await this.callLLM(prompt);

        // Escribir archivo de documentaciÃ³n
        const filePath = `${vscode.workspace.rootPath}/docs/api/register.md`;
        const uri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(docContent, 'utf8'));

        await this.saveToMemory({ filePath, content: docContent }, {
          type: 'documentation',
          project: input
        });

        return {
          output: `Documentation generated at ${filePath}`,
          metadata: { filePath, content: docContent }
        };
      }
    }
    ```

- **MemoryAgent**
  - **Responsabilidad**: Gestiona el contexto global, con soporte para VS Code.
  - **Capacidades**:
    - Almacena cÃ³digo, estados, mÃ©tricas, decisiones, tendencias del mercado, preferencias del usuario.
    - Proporciona contexto histÃ³rico a todos los agentes.
    - Usa almacenamiento local en VS Code (`vscode.Memento`, `vscode.workspace.fs`) para modo offline.
  - **Persistencia de Contexto**:
    - Guarda en `cjdevmind.db` (SQLite) y en Pinecone/Neo4j (en lÃ­nea).
    - Checkpoints cada 100 operaciones o 10 minutos.
    - Usa Faiss para bÃºsqueda vectorial en modo offline.
  - **Interacciones**:
    - Proporciona datos a todos los agentes.
    - Colabora con el **OrchestratorAgent** para mantener el grafo de dependencias.
    - Soporta al **SelfImprovementAgent** proporcionando historial de ejecuciÃ³n.
  - **Ejemplo**:
    - Entrada: "Guardar esquema de base de datos."
    - Salida: Esquema almacenado en `cjdevmind.db` y en el **Sistema de Memoria**.
  - **ImplementaciÃ³n**:
    ```typescript
    class MemoryAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const data = JSON.parse(input);
        const metadata = { type: data.type, project: data.project };
        await this.saveToMemory(data.content, metadata);

        return {
          output: `Data stored: ${data.type}`,
          metadata: { data, metadata }
        };
      }
    }
    ```

#### 7. Negocio (Estrategia y Lanzamiento)

- **BusinessAgent**
  - **Responsabilidad**: EvalÃºa la viabilidad econÃ³mica de un proyecto.
  - **Capacidades**:
    - Analiza costos, beneficios, y ROI.
    - Propone estrategias de monetizaciÃ³n.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Colabora con el **AnalyticsAgent** para datos financieros.
    - Proporciona informaciÃ³n al **LaunchAgent**.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar los anÃ¡lisis.
  - **Ejemplo**:
    - Entrada: "Evaluar viabilidad de un sistema MLM con AR."
    - Salida: Reporte (costo: $5000, beneficio proyectado: $15000).
  - **ImplementaciÃ³n**:
    ```typescript
    class BusinessAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const metrics = await this.queryMemory('metrics');
        const prompt = `Evaluate business viability for: ${input}, using metrics: ${JSON.stringify(metrics)}`;
        const report = await this.callLLM(prompt);

        await this.saveToMemory(report, {
          type: 'business-report',
          project: input
        });

        return {
          output: JSON.stringify(report, null, 2),
          metadata: { report }
        };
      }
    }
    ```

- **MarketAgent**
  - **Responsabilidad**: Analiza tendencias del mercado.
  - **Capacidades**:
    - Recopila datos sobre software demandado (por ejemplo, "MLM con AR es tendencia").
    - Propone caracterÃ­sticas basadas en tendencias.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ COMPLETED.
  - **Interacciones**:
    - Usa el **MemoryAgent** para almacenar tendencias.
    - Colabora con el **BusinessAgent** para estrategias.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar los anÃ¡lisis de mercado.
  - **Ejemplo**:
    - Entrada: "Analizar tendencias para un sistema MLM."
    - Salida: Reporte (tendencia: integraciÃ³n con AR, multilenguaje).
  - **ImplementaciÃ³n**:
    ```typescript
    class MarketAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const trends = await this.queryMemory('market-trends');
        const prompt = `Analyze market trends for: ${input}, using data: ${JSON.stringify(trends)}`;
        const report = await this.callLLM(prompt);

        await this.saveToMemory(report, {
          type: 'market-report',
          project: input
        });

        return {
          output: JSON.stringify(report, null, 2),
          metadata: { report }
        };
      }
    }
    ```

- **LaunchAgent**
  - **Responsabilidad**: Planifica el lanzamiento de un proyecto.
  - **Capacidades**:
    - Crea planes de lanzamiento (por ejemplo, mercados objetivo, estrategias de marketing).
    - Coordina con el **DevOpsAgent** para despliegues finales.
  - **Ciclo de Vida de Tareas**: PENDING â†’ IN_PROGRESS â†’ REVIEW â†’ COMPLETED.
  - **Interacciones**:
    - Depende del **BusinessAgent** y **MarketAgent** para datos.
    - Colabora con el **DashboardAgent** para mostrar el plan.
    - Puede ser optimizado por el **SelfImprovementAgent** para mejorar los planes de lanzamiento.
  - **Ejemplo**:
    - Entrada: "Planificar lanzamiento de un sistema MLM con AR."
    - Salida: Plan (mercados: inglÃ©s/espaÃ±ol, marketing: redes sociales).
  - **ImplementaciÃ³n**:
    ```typescript
    class LaunchAgent extends BaseAgent {
      async execute(input: string): Promise<AgentResult> {
        const businessReport = await this.queryMemory('business-report');
        const marketReport = await this.queryMemory('market-report');
        const prompt = `Plan a launch for: ${input}, using business data: ${JSON.stringify(businessReport)}, market data: ${JSON.stringify(marketReport)}`;
        const plan = await this.callLLM(prompt);

        await this.saveToMemory(plan, {
          type: 'launch-plan',
          project: input
        });

        return {
          output: JSON.stringify(plan, null, 2),
          metadata: { plan }
        };
      }
    }
    ```

#### 8. Otros (IntegraciÃ³n con VS Code)

- **VSCodeAgentBridge**
  - **Responsabilidad**: Puente para ejecutar agentes dentro de VS Code (no es un agente especializado, sino un componente de integraciÃ³n).
  - **Capacidades**:
    - Registra comandos de VS Code para cada agente (`cjdevmind.[agent]`).
    - Gestiona la comunicaciÃ³n entre agentes y el entorno de VS Code.
    - Usa WebSockets para conectar con un servidor backend para tareas pesadas.
  - **Interacciones**:
    - Colabora con todos los agentes para ejecutar tareas.
    - Usa el **VSCodeAdapter** para interactuar con VS Code.
  - **Ejemplo**:
    - Entrada: Comando `cjdevmind.question` en VS Code.
    - Salida: **QuestionAgent** ejecutado, con resultados mostrados en VS Code.
  - **ImplementaciÃ³n**:
    ```typescript
    class VSCodeAgentBridge {
      private context: vscode.ExtensionContext;

      constructor(context: vscode.ExtensionContext) {
        this.context = context;
      }

      registerCommands() {
        const agents = [
          'question', 'vision', 'architect', 'orchestrator', 'extension',
          'uiDesign', 'layout', 'component', 'frontendSync', 'style',
          'api', 'logic', 'database', 'integration',
          'testing', 'security', 'performance', 'refactor', 'test', 'selfImprovement', 'codeReview',
          'devops', 'monitor', 'dashboard', 'analytics',
          'doc', 'memory',
          'business', 'market', 'launch'
        ];

        agents.forEach(agent => {
          this.context.subscriptions.push(
            vscode.commands.registerCommand(`cjdevmind.${agent}`, async () => {
              const agentInstance = AgentFactory.create(agent, { context: this.context });
              const input = await vscode.window.showInputBox({ prompt: `Enter input for ${agent}` });
              if (input) {
                const result = await agentInstance.execute(input);
                vscode.window.showInformationMessage(result.output);
              }
            })
          );
        });
      }

      async executeAgent(agentName: string, input: string): Promise<AgentResult> {
        const agent = AgentFactory.create(agentName, { context: this.context });
        return agent.execute(input);
      }
    }
    ```

---

### Sistema de Memoria (Actualizado)

- **Almacenamiento Online**:
  - Pinecone para bÃºsqueda vectorial de contexto (por ejemplo, embeddings de imÃ¡genes, cÃ³digo, documentaciÃ³n).
  - Neo4j para el grafo de dependencias dinÃ¡mico (relaciones entre tareas, agentes, y datos).
- **Almacenamiento Offline**:
  - Faiss para bÃºsqueda vectorial local.
  - SQLite (`cjdevmind.db`) para datos estructurados.
  - Almacenamiento local de VS Code (`vscode.Memento`, `vscode.workspace.fs`) para datos rÃ¡pidos y preferencias del usuario.
- **Persistencia de Contexto**:
  - Checkpoints automÃ¡ticos cada 100 operaciones o 10 minutos.
  - SincronizaciÃ³n al reconectar en modo offline.
- **Interacciones**:
  - Gestionado por el **MemoryAgent**, que proporciona contexto a todos los agentes.
  - Usado por el **SelfImprovementAgent** para analizar historiales de ejecuciÃ³n y optimizar agentes.
- **Ejemplo**:
  ```json
  {
    "type": "component",
    "project": "mlm-system",
    "data": {
      "filePath": "/src/components/LoginButton.tsx",
      "code": "export const LoginButton = () => { ... }"
    },
    "metadata": {
      "created": "2025-04-12T10:00:00Z",
      "reviewedBy": "CodeReviewAgent"
    }
  }
  ```

---

### EventBus

- **ImplementaciÃ³n**: Sistema de publicaciÃ³n/suscripciÃ³n basado en canales temÃ¡ticos.
- **Canales**:
  - `frontend`: Para eventos de **UIDesignAgent**, **LayoutAgent**, **ComponentAgent**, **FrontendSyncAgent**, y **StyleAgent**.
  - `backend`: Para eventos de **APIAgent**, **LogicAgent**, **DatabaseAgent**, y **IntegrationAgent**.
  - `calidad`: Para eventos de **TestingAgent**, **SecurityAgent**, **PerformanceAgent**, **RefactorAgent**, **TestAgent**, **SelfImprovementAgent**, y **CodeReviewAgent**.
  - `infraestructura`: Para eventos de **DevOpsAgent**, **MonitorAgent**, **DashboardAgent**, y **AnalyticsAgent**.
  - `documentacion`: Para eventos de **DocAgent** y **MemoryAgent**.
  - `negocio`: Para eventos de **BusinessAgent**, **MarketAgent**, y **LaunchAgent**.
  - `meta`: Para eventos de **QuestionAgent**, **VisionAgent**, **ArchitectAgent**, **OrchestratorAgent**, y **ExtensionAgent**.
- **Ejemplo**:
  ```typescript
  class EventBus {
    private static instance: EventBus;
    private subscribers: Map<string, ((data: any) => void)[]>;

    private constructor() {
      this.subscribers = new Map();
    }

    static getInstance(): EventBus {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    subscribe(channel: string, callback: (data: any) => void): void {
      if (!this.subscribers.has(channel)) {
        this.subscribers.set(channel, []);
      }
      this.subscribers.get(channel)!.push(callback);
    }

    publish(channel: string, data: any): void {
      const callbacks = this.subscribers.get(channel) || [];
      for (const callback of callbacks) {
        callback(data);
      }
    }
  }
  ```

---

### VSCodeAdapter

- **Responsabilidad**: AbstracciÃ³n para interactuar con la API de VS Code.
- **Capacidades**:
  - Registro de comandos (`vscode.commands.registerCommand`).
  - Escritura/lectura de archivos (`vscode.workspace.fs`).
  - Almacenamiento local (`vscode.Memento`, `vscode.workspace.fs`).
  - Almacenamiento seguro de claves (`vscode.SecretStorage`).
  - Renderizado de webviews para dashboard y previsualizaciones.
  - Notificaciones al usuario (`vscode.window.showInformationMessage`).
- **Ejemplo**:
  ```typescript
  class VSCodeAdapter {
    private context: vscode.ExtensionContext;

    constructor(context: vscode.ExtensionContext) {
      this.context = context;
    }

    registerCommand(command: string, callback: (...args: any[]) => any): void {
      this.context.subscriptions.push(
        vscode.commands.registerCommand(command, callback)
      );
    }

    async storeLocalData(key: string, value: any): Promise<void> {
      await this.context.workspaceState.update(key, value);
    }

    async getLocalData(key: string): Promise<any> {
      return this.context.workspaceState.get(key);
    }

    async storeSecret(key: string, value: string): Promise<void> {
      await this.context.secrets.store(key, value);
    }

    async getSecret(key: string): Promise<string | undefined> {
      return this.context.secrets.get(key);
    }

    async showWebview(viewId: string, htmlContent: string): Promise<void> {
      const panel = vscode.window.createWebviewPanel(
        viewId,
        viewId === 'dashboard' ? 'CJ.DevMind Dashboard' : 'Preview',
        vscode.ViewColumn.One,
        {}
      );
      panel.webview.html = htmlContent;
    }
  }
  ```

---

### LLMProvider

- **Responsabilidad**: Gestiona las interacciones con modelos de lenguaje.
- **Capacidades**:
  - Soporte para mÃºltiples proveedores (OpenAI, Anthropic, modelos locales como Llama y Mistral).
  - GestiÃ³n de prompts optimizados por agente.
  - Cache de respuestas para mejorar rendimiento.
- **OptimizaciÃ³n**:
  - El **SelfImprovementAgent** ajusta los prompts dinÃ¡micamente basÃ¡ndose en el historial de ejecuciÃ³n.
- **Ejemplo**:
  ```typescript
  class LLMProvider {
    private provider: string;
    private cache: Map<string, string>;

    constructor(provider: string) {
      this.provider = provider;
      this.cache = new Map();
    }

    async call(prompt: string, options?: LLMOptions): Promise<string> {
      const cacheKey = `${prompt}:${JSON.stringify(options)}`;
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey)!;
      }

      let response: string;
      if (this.provider === 'openai') {
        response = await this.callOpenAI(prompt, options);
      } else if (this.provider === 'anthropic') {
        response = await this.callAnthropic(prompt, options);
      } else {
        response = await this.callLocalModel(prompt, options);
      }

      this.cache.set(cacheKey, response);
      return response;
    }

    private async callOpenAI(prompt: string, options?: LLMOptions): Promise<string> {
      // SimulaciÃ³n de llamada a OpenAI
      return `Response from OpenAI for: ${prompt}`;
    }

    private async callAnthropic(prompt: string, options?: LLMOptions): Promise<string> {
      // SimulaciÃ³n de llamada a Anthropic
      return `Response from Anthropic for: ${prompt}`;
    }

    private async callLocalModel(prompt: string, options?: LLMOptions): Promise<string> {
      // SimulaciÃ³n de llamada a modelo local
      return `Response from local model for: ${prompt}`;
    }
  }
  ```

---

### GitAdapter

- **Responsabilidad**: Gestiona puntos de restauraciÃ³n y rollbacks.
- **Capacidades**:
  - Crea commits automÃ¡ticos antes de cambios crÃ­ticos.
  - Permite rollbacks a estados anteriores.
  - Usa la API de Git integrada en VS Code.
- **Ejemplo**:
  ```typescript
  class GitAdapter {
    private repoPath: string;

    constructor(repoPath: string) {
      this.repoPath = repoPath;
    }

    async commit(message: string): Promise<void> {
      const git = new (require('simple-git'))(this.repoPath);
      await git.add('.');
      await git.commit(message);
    }

    async rollback(commitHash: string): Promise<void> {
      const git = new (require('simple-git'))(this.repoPath);
      await git.reset(['--hard', commitHash]);
    }
  }
  ```

---

### Modelo de Negocio

#### Licencias
- **Community**: Acceso bÃ¡sico, limitado a 5 agentes y 50 crÃ©ditos iniciales.
- **Professional**: Acceso a todos los agentes, 500 crÃ©ditos iniciales, soporte prioritario.
- **Enterprise**: Acceso completo, crÃ©ditos ilimitados, soporte dedicado, y personalizaciÃ³n.

#### Sistema de CrÃ©ditos
- **Uso**:
  - 10 crÃ©ditos por tarea compleja (por ejemplo, generar un componente con AR).
  - 50 crÃ©ditos por extensiones del marketplace (por ejemplo, plugin de AR).
- **AdquisiciÃ³n**:
  - Incluidos con la licencia.
  - Compra adicional vÃ­a el marketplace (gestionado por el **ExtensionAgent**).

#### Marketplace
- **Extensiones Disponibles**:
  - Plugins de AR, multilenguaje, temas personalizados.
- **IntegraciÃ³n**:
  - Gestionado por el **ExtensionAgent**.
  - Mostrado en el dashboard de VS Code (via **DashboardAgent**).

---

### Seguridad (Actualizada)

#### Medidas de Seguridad
- **GestiÃ³n de Credenciales**:
  - Claves API almacenadas en `vscode.SecretStorage`.
  - Gestionadas por el **IntegrationAgent** y **SecurityAgent**.
- **ValidaciÃ³n de Entrada**:
  - SanitizaciÃ³n de entradas del usuario para evitar inyecciones (por ejemplo, SQL injection, XSS).
  - Implementada por el **SecurityAgent**.
- **AuditorÃ­a**:
  - Logs transaccionales para todas las operaciones crÃ­ticas.
  - Gestionados por el **OrchestratorAgent**.
- **Niveles de AprobaciÃ³n**:
  - Tareas en estado REVIEW requieren aprobaciÃ³n humana.
  - Notificaciones enviadas mediante `vscode.window.showInformationMessage`.
- **Rollbacks AutomÃ¡ticos**:
  - Puntos de restauraciÃ³n creados por el **GitAdapter**.
  - Usados por agentes como **APIAgent**, **SecurityAgent**, y **DevOpsAgent**.
- **Code Review**:
  - El **CodeReviewAgent** revisa el cÃ³digo generado para detectar vulnerabilidades y asegurar calidad.

#### Ejemplo de Seguridad
- **Entrada**: Endpoint `/register` generado por el **APIAgent**.
- **Proceso**:
  - **SecurityAgent** aplica JWT y sanitizaciÃ³n de entradas.
  - **CodeReviewAgent** revisa el cÃ³digo para detectar vulnerabilidades.
  - **GitAdapter** crea un punto de restauraciÃ³n antes de aplicar cambios.
- **Salida**: Endpoint seguro en `src/backend/routes/auth.js`.

---

### Escalabilidad y Rendimiento (Actualizada)

#### Escalabilidad
- **Arquitectura HÃ­brida**:
  - Cliente ligero en VS Code para tareas rÃ¡pidas (por ejemplo, renderizado de webviews, comandos).
  - Servidor backend para tareas pesadas (por ejemplo, procesamiento de imÃ¡genes, generaciÃ³n de cÃ³digo).
  - ComunicaciÃ³n vÃ­a WebSockets para actualizaciones en tiempo real.
- **Modo Offline**:
  - Modelos locales (Llama, Mistral) para generaciÃ³n de cÃ³digo.
  - Almacenamiento local (`vscode.Memento`, `vscode.workspace.fs`) para datos y contexto.
  - SincronizaciÃ³n automÃ¡tica al reconectar.
- **Soporte Multi-Proyecto**:
  - El **MemoryAgent** separa el contexto por proyecto (`project_id`).
  - El **OrchestratorAgent** gestiona tareas de mÃºltiples proyectos simultÃ¡neamente.

#### Rendimiento
- **Cache de Respuestas**:
  - Implementado en el **LLMProvider** para evitar consultas repetitivas.
- **PriorizaciÃ³n Inteligente**:
  - El **OrchestratorAgent** usa una **PriorityQueue** para gestionar tareas.
- **OptimizaciÃ³n DinÃ¡mica**:
  - El **SelfImprovementAgent** analiza el historial de ejecuciÃ³n y ajusta prompts y configuraciones para mejorar el rendimiento.
- **MÃ©tricas**:
  - El **MonitorAgent** registra mÃ©tricas de rendimiento (latencia, uso de CPU).
  - El **PerformanceAgent** propone optimizaciones basadas en mÃ©tricas.

---

### Ejemplo Completo: Sistema MLM con Realidad Aumentada (Actualizado)

#### Flujo de Trabajo
1. **Entrada del Usuario**:
   - Comando en VS Code: `cjdevmind.question` con "Crear un sistema MLM con realidad aumentada."
2. **QuestionAgent**:
   - Descompone el requerimiento y genera tareas mediante un cuestionario interactivo en VS Code.
   - Tareas: DiseÃ±ar UI, implementar AR, crear APIs, asegurar calidad, desplegar.
3. **OrchestratorAgent**:
   - Construye un grafo de dependencias y asigna tareas a los agentes.
   - Usa el **MemoryAgent** para almacenar el contexto.
4. **ArchitectAgent**:
   - Define arquitectura: React (Frontend), Node.js (Backend), PostgreSQL (DB), ARKit (AR).
   - Crea estructura de carpetas en `src/`.
5. **Frontend**:
   - **UIDesignAgent**: DiseÃ±a un sistema de diseÃ±o (tema oscuro, tipografÃ­a: Roboto).
   - **StyleAgent**: Genera `src/styles/theme-dark.css` y actualiza Tailwind.
   - **LayoutAgent**: Crea `DashboardLayout.jsx` con un layout responsive.
   - **ComponentAgent**: Genera `ARComponent.tsx` para realidad aumentada, con documentaciÃ³n.
   - **FrontendSyncAgent**: Conecta el frontend con los endpoints del backend.
6. **Backend**:
   - **APIAgent**: Crea endpoint `/register` en `src/backend/routes/auth.js`.
   - **LogicAgent**: Implementa lÃ³gica de comisiones MLM en `src/backend/logic/commissions.js`.
   - **DatabaseAgent**: Genera esquema `users` en `src/backend/migrations/001_create_users.sql`.
   - **IntegrationAgent**: Integra ARKit para componentes AR.
7. **Calidad**:
   - **TestingAgent**: Escribe pruebas Jest para `/register` en `src/backend/tests/auth.test.js`.
   - **TestAgent**: Genera pruebas de accesibilidad para `ARComponent.tsx`.
   - **SecurityAgent**: Aplica JWT y sanitizaciÃ³n al endpoint `/register`.
   - **PerformanceAgent**: Optimiza consultas a la tabla `users`.
   - **RefactorAgent**: Refactoriza `commissions.js` para mayor claridad.
   - **CodeReviewAgent**: Revisa `ARComponent.tsx` y propone mejoras.
   - **SelfImprovementAgent**: Optimiza los prompts del **UIDesignAgent** basÃ¡ndose en el historial.
8. **Infraestructura**:
   - **DevOpsAgent**: Configura pipeline en `.github/workflows/deploy.yml`.
   - **MonitorAgent**: Registra mÃ©tricas (latencia: 150ms, CPU: 4%).
   - **DashboardAgent**: Muestra el estado en un webview de VS Code.
   - **AnalyticsAgent**: Calcula ROI (inversiÃ³n: $5000, retorno: $15000).
9. **DocumentaciÃ³n**:
   - **DocAgent**: Genera documentaciÃ³n del endpoint `/register` en `docs/api/register.md`.
   - **MemoryAgent**: Almacena el contexto del proyecto.
10. **Negocio**:
    - **BusinessAgent**: EvalÃºa viabilidad (costo: $5000, beneficio: $15000).
    - **MarketAgent**: Analiza tendencias (AR y multilenguaje son clave).
    - **LaunchAgent**: Crea plan de lanzamiento (mercados: inglÃ©s/espaÃ±ol, marketing: redes sociales).
11. **VSCodeAgentBridge**:
    - Ejecuta comandos y muestra resultados en VS Code.

#### Resultado Final
- Proyecto funcional en `src/` con frontend (React, ARKit), backend (Node.js, PostgreSQL), documentaciÃ³n, y pipeline de CI/CD.
- Dashboard en VS Code mostrando mÃ©tricas, ROI, y plan de lanzamiento.
- CÃ³digo revisado por **CodeReviewAgent**, con pruebas automatizadas por **TestAgent**, y optimizaciones por **SelfImprovementAgent**.

---

### Futuras Mejoras (Actualizadas)

#### Nuevas Funcionalidades
- **Soporte Multi-Idioma**:
  - GeneraciÃ³n de prompts y documentaciÃ³n en mÃºltiples idiomas (inglÃ©s, espaÃ±ol, francÃ©s).
  - Gestionado por el **DocAgent** y el **MemoryAgent**.
- **IntegraciÃ³n con Herramientas de AR Avanzadas**:
  - Soporte para ARCore y herramientas de AR basadas en IA.
  - Gestionado por el **IntegrationAgent** y el **ComponentAgent**.
- **AnÃ¡lisis Predictivo**:
  - Predecir problemas de rendimiento o seguridad antes de que ocurran.
  - Implementado por el **AnalyticsAgent** y el **SelfImprovementAgent**.

#### Optimizaciones
- **ReducciÃ³n de Latencia**:
  - Cache mÃ¡s agresivo en el **LLMProvider**.
  - Pre-carga de modelos locales en modo offline.
- **Mejora del Modo Offline**:
  - SincronizaciÃ³n mÃ¡s eficiente al reconectar.
  - Almacenamiento local optimizado para proyectos grandes.
- **Auto-OptimizaciÃ³n Avanzada**:
  - El **SelfImprovementAgent** podrÃ­a usar aprendizaje por refuerzo para optimizar agentes en tiempo real.

#### Seguridad
- **AutenticaciÃ³n Multi-Factor**:
  - Para el acceso a funcionalidades crÃ­ticas (por ejemplo, despliegues).
  - Gestionado por el **SecurityAgent**.
- **AnÃ¡lisis de Dependencias**:
  - Detectar vulnerabilidades en dependencias externas.
  - Implementado por el **SecurityAgent** y el **CodeReviewAgent**.

---

### ConclusiÃ³n

**CJ.DevMind** es un sistema robusto y escalable que ahora incluye **30 agentes especializados**, con la adiciÃ³n de **StyleAgent**, **TestAgent**, **SelfImprovementAgent**, **CodeReviewAgent**, y una versiÃ³n mejorada de **ComponentAgent**. La jerarquÃ­a total tiene 32 elementos, incluyendo `BaseAgent` (nÃºcleo) y `VSCodeAgentBridge` (componente de integraciÃ³n). La integraciÃ³n con VS Code permite una experiencia de desarrollo fluida, con soporte para proyectos de cualquier escala, desde pequeÃ±as aplicaciones hasta sistemas complejos como un MLM con realidad aumentada. La arquitectura hÃ­brida, el modo offline, la persistencia de contexto, y las nuevas capacidades de revisiÃ³n, autoextensiÃ³n (via **ExtensionAgent**) y automejora (via **SelfImprovementAgent**) aseguran un desarrollo eficiente, seguro, y optimizado, con un enfoque en la calidad del cÃ³digo y la experiencia del usuario.

---
